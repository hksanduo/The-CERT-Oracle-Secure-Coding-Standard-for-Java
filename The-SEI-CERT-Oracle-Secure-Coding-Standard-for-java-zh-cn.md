# SEI CERT Oracle java 安全编码规范
## 前言

## 编码规范

### 00.输入输出数据验证(IDS)
#### IDS00.防止SQL注入
#### IDS01.验证之前先对字符串进行格式化
#### IDS02.验证之前先对路径名进行格式化(已弃用)
#### IDS03.防止日志注入
#### IDS04.防止zip解压目录穿越漏洞
#### IDS05.使用规范命名的路径和文件名(已弃用)
#### IDS06.禁止在字符串中拼接未处理的用户输入数据
#### IDS07.防止命令注入
#### IDS08.防止正则表达式注入
#### IDS09.格式化数据后进行判断比较(已弃用)
#### IDS10.不要构建包含特殊字符的字符串(已弃用)
#### IDS11.在验证之前处理字符串
#### IDS13.在文件中和网络传输的IO流中使用相互兼容的编码(已弃用)
#### IDS14.不应信任隐藏表单中的内容
#### IDS15.禁止泄露敏感数据(保留)
#### IDS16.防止xml注入
#### IDS17.防止xml外部实体注入

### 01.声明和初始化(DCL)
#### DCL00.防止类在初始化时循环申明
#### DCL01.不要重复使用Java标准库中的公共标识符
#### DCL02.不要再增强的for循环中修改集合

### 02.表达式(EXP)
#### EXP00.不要忽略方法返回值
#### EXP01.禁止空对象引用
#### EXP02.不要使用Object.equals()方法来比较数组
#### EXP03.不要使用相等运算符来比较装箱类型数据
#### EXP04.不要将参数传递给与集合参数类型不同的java框架方法
#### EXP05.不要在表达式中写入或者读取同一对象后续赋值(已弃用)
#### EXP06.表达式中调用assert语句不能产生歧义
#### EXP07.防止因弱引用丢失数据(保留)

### 03.数值类型和操作(NUM)
#### NUM00.防止整数溢出
#### NUM01.不要对同一数据执行按位和算术运算
#### NUM02.防止除法和取余除数为0
#### NUM03.使用完全可以表示无符号数据范围的整数类型
#### NUM04.禁止使用浮点数进行精确计算(已弃用)
#### NUM07.不要和NAN进行比较
#### NUM08.检查浮点输入的异常值
#### NUM09.不要使用浮点变量作为循环计数器
#### NUM10.不要使用浮点数字构建BigDecimal对象
#### NUM11.不要比较或者检查浮点值的字符串
#### NUM12.确保数值类型转换占位小的类型不会导致数据丢失
#### NUM13.将整数转换为浮点数时避免精度损失
#### NUM14.正确使用移位运算符

### 04.字符和字符串(STR)
#### STR00.不要拼接可变长度编码的字符串
#### STR01.java字符集不等同于Unicode字符集
#### STR02.使用相同的语言环境中对比数据
#### STR03.不要使用非字符数据转化为字符串
#### STR04.在JVM之间通信传输数据使用相互兼容的字符编码

### 05.面向对象(OBJ)
#### OBJ01.限制对象属性方法的作用域
#### OBJ02.更改超类时保留子类中的依赖关系
#### OBJ03.防止堆污染
#### OBJ04.创建具有复制功能的可变类，允许将实例传递给不信任的代码
#### OBJ05.不要返回对私有可变类成员的引用
#### OBJ06.防御复制可变输入和可变的内部组件
#### OBJ07.不要复制包含私有、机密或者敏感数据的类
#### OBJ08.不要从嵌套类中公开外部类的私有成员
#### OBJ09.比较类而不是类名
#### OBJ10.不要使用公共静态非最终的字段
#### OBJ11.注意不要让构造函数抛出异常
#### OBJ12.尊重基于对象的注释(保留)
#### OBJ13.确保不公开对可变对象的引用
#### OBJ14.不要使用已释放的对象

### 06.方法(MET)
#### MET00.验证方法参数
#### MET01.不要使用assert来验证方法参数
#### MET02.不要使用已弃用或过时的类或方法
#### MET03.执行安全检查的方法必须声明为私有的或最终的
#### MET04.不要增加覆盖或隐藏方法的可访问性
#### MET05.确保构造函数不调用可覆盖的方法
#### MET06.不要在 clone() 中调用可覆盖的方法
#### MET07.永远不要声明隐藏在超类或超接口中声明的方法的类方法
#### MET08.重写equals()方法时保留相等约定
#### MET09.定义 equals() 方法的类也必须定义 hashCode() 方法
#### MET10.在实现compareTo()方法时遵循通用约定
#### MET11.确保在比较操作中使用的键是不可变的
#### MET12.不要使用finalizers
#### MET13.不要假设重新分配方法参数会修改调用环境(保留)

### 07.异常(ERR)
#### ERR00.不要抑制或忽略检查异常
#### ERR01.不允许异常暴露敏感信息
#### ERR02.记录数据时防止异常
#### ERR03.在方法失败时恢复先前的对象状态
#### ERR04.不要从 finally 代码中突然完成任务
#### ERR05.不要让检查异常从 finally 代码中逃脱
#### ERR06.不要抛出未声明的异常
#### ERR07.不允许抛出 RuntimeException、Exception 或 Throwable
#### ERR08.不应捕获NullPointerException或者其他基类
#### ERR09.不允许不受信任的代码终止 JVM

### 08.可见性和原子性(VNA)
#### VNA00.确保访问共享原始变量时的可见性
#### VNA01.确保对不可变对象的共享引用的可见性
#### VNA02.确保对共享变量上的复合操作是原子的
#### VNA03.不要假设一组对独立原子方法的调用是原子的
#### VNA04.确保对链接方法的调用是原子的
#### VNA05.在读取和写入64位值时确保原子性

### 09.锁定(LCK)
#### LCK00.使用私有最终锁定的对象同步可能与不受信任代码交互
#### LCK01.不要同步可能重用的对象
#### LCK02.不同步 getClass() 返回的类对象
#### LCK03.不同步高级并发对象的内在锁
#### LCK04.如果后备集合可访问，则不要在集合视图上同步
#### LCK05.同步访问可以被不受信任的代码修改的静态字段
#### LCK06.不要使用实例锁来保护共享的静态数据
#### LCK07.通过以相同的顺序请求和释放锁来避免死锁
#### LCK08.确保在异常情况下主动释放持有的锁
#### LCK09.持有锁时不要执行会阻塞的操作
#### LCK10.使用正确形式的双重检查锁定习惯用法
#### LCK11.使用不符合其锁定策略的类时避免客户端锁定

### 10.不安全的线程接口(THI)
#### THI00.不要调用 Thread.run()
#### THI01.不要调用 ThreadGroup 方法
#### THI02.通知所有等待线程而不是单个线程
#### THI03.始终在循环内调用 wait() 和 await() 方法
#### THI04.确保可以终止执行阻塞操作的线程
#### THI05.不要使用 Thread.stop() 来终止线程

### 11.不安全的线程池(TPS)
#### TPS00.在线程池过载期间实现服务稳定降级
#### TPS01.不要在有界线程池中执行相互依赖的任务
#### TPS02.确保提交到线程池的任务是可中断的
#### TPS03.确保在线程池中执行的任务不会静默失败
#### TPS04.确保在使用线程池时重新初始化 ThreadLocal 变量

### 12.线程安全(TSM)
#### TSM00.不要用非线程安全的方法覆盖线程安全的方法
#### TSM01.在对象构造期间不要让 this 引用逃逸
#### TSM02.在类初始化期间不要使用后台线程
#### TSM03.不要发布部分初始化的对象

### 13.输入输出流(FIO)
#### FIO00.不要对共享目录中的文件进行操作
#### FIO01.创建具有适当访问权限的文件
#### FIO02.检测和处理与文件相关的错误
#### FIO03.终止前删除临时文件
#### FIO04.不再需要时释放资源
#### FIO05.不要将缓冲区或其后备数组方法暴露给不受信任的代码
#### FIO06.不要在单个字节或字符流上创建多个缓冲包装器
#### FIO07.不要让外部进程阻塞 IO 缓冲区
#### FIO08.区分从流中读取的字符或字节和 -1
#### FIO09.不要依赖 write() 方法来输出 0 到 255 范围之外的整数
#### FIO10.确保在使用 read() 填充数组时填充数组
#### FIO11.不要在没有指定有效字符编码的情况下在字符串和字节之间进行转换(已弃用)
#### FIO12.提供读写小端数据的方法
#### FIO13.不要在信任边界之外记录敏感信息
#### FIO14.在程序终止时执行适当的清理操作
#### FIO15.提交后不要重置 servlet 的输出流
#### FIO16.在验证之前格式化路径名

### 14.序列化(SER)
#### SER00.在类演化期间启用序列化兼容性
#### SER01.不要脱离序列化方法的正确签名
#### SER02.签名打包对象后发送到信任的接口
#### SER03.不要序列化未加密的敏感数据
#### SER04.不允许序列化和反序列化绕过安全管理器
#### SER05.不要序列化内部类的实例
#### SER06.在反序列化期间对私有可变组件进行安全复制
#### SER07.对于具有实现定义的不变量的类，不要使用默认的序列化形式
#### SER08.在对特权上下文进行反序列化之前，将特权最小化
#### SER09.不要从 readObject() 方法调用可覆盖的方法
#### SER10.避免序列化过程中的内存和资源泄漏
#### SER11.防止覆盖外部化对象
#### SER12.防止对不受信任的数据进行反序列化
#### SER13.反序列化方法不应执行有潜在危险的操作(已弃用)

### 15.平台安全(SEC)
#### SEC00.不允许特权块跨信任边界泄漏敏感信息
#### SEC01.不允许在特权块中使用受污染的变量
#### SEC03.在允许不受信任的代码加载任意类后不要加载受信任的类
#### SEC05.不要使用反射来增加类、方法或字段的可访问性
#### SEC08.受信任代码必须丢弃或清除不受信任代码提供的任何参数(已移除)
#### SEC09.永远不要将某些标准 API 方法的结果从可信代码泄露到不可信代码(已移除)
#### SEC10.绝不允许不受信任的代码调用任何可能（可能传递地）调用反射 API 的 API(已移除)
#### SEC02.不要基于不受信任的来源进行安全检查
#### SEC04.通过安全管理器检查保护敏感操作
#### SEC06.不要依赖 URLClassLoader 和 java.util.jar 提供的默认自动签名验证
#### SEC07.编写自定义类加载器时调用超类的 getPermissions() 方法

### 16.运行环境(ENV)
#### ENV00.不要签署只执行非特权操作的代码
#### ENV01.将所有安全敏感代码放在一个 JAR 中并签名并密封
#### ENV02.不要相信环境变量的值
#### ENV03.不要授予危险的权限组合
#### ENV04.不要禁用字节码验证
#### ENV05.不要部署可以远程监控的应用程序
#### ENV06.生产代码不得包含调试接口

### 17.JNI接口(JNI)
#### JNI00.定义本机方法的包装器
#### JNI01.使用直接调用的类加载器实例 (loadLibrary) 安全调用执行任务的标准 API
#### JNI02.不要假设对象引用是常量或唯一的(编写中)
#### JNI03.不要在 JNI 代码中使用指向 Java 对象的直接指针(编写中)
#### JNI04.不要假设 Java 字符串是以空字符结尾的(编写中)

### 49.其他(MSC)
#### MSC00.使用 SSLSocket 而不是 Socket 传输数据
#### MSC01.不要使用空的死循环
#### MSC02.使用强随机数
#### MSC03.禁止硬编码敏感信息
#### MSC04.禁止内存泄露
#### MSC05.避免耗尽堆空间
#### MSC06.在迭代过程中不要修改底层集合
#### MSC07.防止单例对象多个实例化
#### MSC08.不要将不可序列化的对象作为属性存储在 HTTP 会话中(保留)
#### MSC09.合理使用OAuth(编写中)
#### MSC10.不要使用OAuth 2.0 默认权限(未修改)进行身份验证(编写中)
#### MSC11.不要让会话信息在 servlet 内泄漏

## 建议
### 00.输入输出数据验证(IDS)
#### IDS50.使用规范命名的路径和文件名
#### IDS51.输入编码或输出转义
#### IDS52.防止代码注入
#### IDS53.防止XPath注入
#### IDS54.防止LDAP注入
#### IDS55.在加载字符串时正确解析转义字符
#### IDS56.防止任意文件上传

### 01.声明和初始化(DCL)
#### DLC50.使用易于区分的标识符
#### DLC51.不要在子作用域中隐藏或模糊标识符
#### DLC52.每个声明不要声明多个变量
#### DLC53.最小化变量的范围
#### DLC54.使用有意义的常量来表示程序逻辑中的文字值
#### DLC55.在常量定义中明确相关关系
#### DLC56.不重视与枚举相关联的序数
#### DLC57.避免可变数量方法的模糊重载
#### DLC58.启用可变参数类型的编译时类型检查
#### DLC59.不要将 public final 应用于其值可能在以后的版本中发生变化的常量
#### DLC60.避免包之间的循环依赖
#### DLC61不要使用原始类型.

### 02.表达式(EXP)
#### EXP50.不要将抽象对象相等与引用相等混淆
#### EXP51.不要在条件表达式中执行赋值
#### EXP52.对 if、for 或 while 语句的主体使用大括号
#### EXP53.使用括号优先操作
#### EXP54.了解按位运算符和逻辑运算符之间的区别
#### EXP55.对条件表达式中的第二个和第三个操作数使用相同的类型

### 03.数值类型和操作(NUM)
#### NUM50.将整数转换为浮点数以进行浮点运算
#### NUM51.不要假设余数运算符总是为整数操作数返回非负结果
#### NUM52.注意数值运算类型不匹配而导致的精度缺失
#### NUM53.使用 strictfp 修饰符实现跨平台的浮点计算一致性
#### NUM54.不要使用非规范化数字

### 04.字符和字符串(STR)
#### STR50.使用适当的方法计算字符串中的字符数
#### STR51.当需要对编码过程进行更多控制时，使用字符集编码器和解码器

### 05.面向对象(OBJ)
#### OBJ50.不要将引用的不变性与被引用对象的不变性混淆
#### OBJ51.最小化类及其成员的访问权限
#### OBJ52.注意编写垃圾回收模块
#### OBJ53.不要对生命周期短、不经常使用的对象直接使用缓冲区操作
#### OBJ54.不要试图通过将本地引用变量设置为 null 来辅助垃圾回收器
#### OBJ55.从长期存在的容器对象中删除短期存在的对象
#### OBJ56.为敏感的可变类提供不可修改的包装器
#### OBJ57.不要依赖可被不可信代码覆盖的方法
#### OBJ58.使用不变量限制类和方法的可扩展性

### 06.方法(MET)
#### MET50.避免含糊不清或混淆的重载用法
#### MET51.不要使用重载方法来区分运行时类型
#### MET52.不要使用 clone() 方法复制不受信任的方法参数
#### MET53.确保 clone() 方法调用 super.clone()
#### MET54.始终提供有关方法结果值的反馈
#### MET55.对于返回数组或集合的方法，返回空数组或集合而不是空值
#### MET56.不要使用 Object.equals() 来比较加密密钥

### 07.异常(ERR)
#### ERR50.仅在异常情况下使用异常
#### ERR51.尽可能用户自定义的异常
#### ERR52.避免内部错误
#### ERR53.尝试从系统错误中完整地恢复
#### ERR54.使用 try-with-resources 语句安全地处理可关闭的资源

### 13.输入输出流(FIO)
#### FIO50.对文件创建做异常处理
#### FIO51.使用多个文件属性识别文件
#### FIO52.不要在客户端存储未加密的敏感信息
#### FIO53.谨慎使用序列化方法 writeUnshared() 和 readUnshared()

### 15.平台安全(SEC)
#### SRC50.最小特权原则
#### SRC51.最小化特权代码
#### SRC52.不要将高风险的方法暴露给不受信任的代码
#### SRC53.自定义细粒度安全权限
#### SRC54.使用安全管理器创建安全沙箱
#### SRC55.确保使用经过验证的参数调用安全敏感方法
#### SRC56.不序列化系统资源的直接句柄
#### SRC57.不要让不受信任的代码滥用回调方法
#### SRC58.反序列化方法不应执行有潜在危险的操作

### 18.并发(CON)
#### CON50.不要假定声明一个引用volatile就能保证被引用对象成员的安全发布
#### CON51.不要假定 sleep()、yield() 或 getState() 方法提供进程同步
#### CON52.记录线程安全并在适用的情况下使用注释

### 49.其他(MSC)
#### MSC50.最小化@SuppressWarnings 注释的范围
#### MSC51.不要在 if、for 或 while 条件后紧跟分号     
#### MSC52.用 break 语句完成与 case 标签关联的每组语句
#### MSC53.在发布之前仔细设计界面
#### MSC54.避免无意中破坏循环计数器
#### MSC55.以一致且可读的方式使用注释
#### MSC56.检测并删除残余的代码和配置
#### MSC57.确保逻辑完整性
#### MSC58.优先使用迭代器而不是枚举
#### MSC59.限制敏感数据的生命周期
#### MSC60.不要使用assert来验证是否存在运行时错误
#### MSC61.不要使用不安全或弱的加密算法
#### MSC62.使用哈希函数存储密码
#### MSC63.确保 SecureRandom 使用正确的随机因子

## 术语
## 参考文献